TaxResidency

AddCountryButton.tsx

TS

country-list.ts

CountryList.tsx

CountryTaxEntry.tsx

TS errorMessage.ts

Other Countries Of TaxResidence.tsx

TS tax-residency-stub.ts

TaxDeclarationCheckbox.tsx

TaxResidency.tsx

TaxResidencyInformation.tsx

TS taxResidencyValidation.ts

TaxResidencyValidations.tsx

United StatesResident.tsx

use CountriesData.tsx

useCountryValidation.tsx

useTaxResidencyData.tsx

YesNoRadioGroup.tsx


Business details API integration review
Form Management Architecture
	•	Main business details file handles API calls, navigation, and validation
	•	Components receive response data as props instead of original form state
	•	Each component section defines own useState and useEffect
	◦	Trading name section updates state from API response
	◦	Business start date section follows same pattern
	◦	Form store saves/updates data for each component
Component Structure & State Management
	•	Leaf components handle specific functionality
	◦	Trading name section includes render trading component
	◦	Function defined in same file with local useState for trading name choice
	◦	Flag-based approach for child component management
	•	Dynamic component addition/removal
	◦	Screen initially loads with 4 components (trading name, business start date, trading address choice, business website)
	◦	Components added/removed from form store based on screen appearance order
	◦	Trading name choice appears as 5th component when user starts typing
Validation & Error Handling System
	•	Next button triggers validation process
	1	Get current form state using form store function
	2	Apply validation config defined for each component
	3	Call validate function from validation service
	4	Receive error codes for each component
	5	Map error codes using error messages file
	6	Store error details in form store
	•	Real-time error management
	◦	Errors removed on typing (onChange events)
	◦	Error panel at top subscribes to form state
	◦	Automatic error removal updates error panel
Implementation Plan
	•	Team member will implement the described architecture
	•	Refactoring approach to be determined



Corrections
Code Restructuring Requirements
	•	Current tax residency validation form behaves like hook but isn’t one
	◦	Form state management too centralized
	◦	Need to isolate each form field’s state management
	•	New architecture approach:
	◦	Break page into 3 separate components (one per visible section)
	◦	Each component manages its own form fields’ states
	◦	Parent component controls when to show/hide sections
	◦	Individual components handle field-specific logic
State Management Pattern
	•	Dual update system for field changes:
	1	Update local component state
	2	Dispatch to global store via debounce function
	•	Validation process:
	◦	Next button triggers check validity method
	◦	Pulls all data from store for validation
	◦	Separate from individual field state management
	•	Reference implementation: Business details page already follows this pattern
Team Coordination Plan
	•	Immediate restructuring required for code sync across team
	•	Schedule call today with Shreya and “the cash guy”
	◦	Include Thanmai kora in call
	◦	Restructure code together in real-time
	◦	Ensure consistent implementation approach
Next Steps
	•	Schedule team call immediately
	•	Restructure tax residency validation code following new architecture
	•	Apply same pattern across all form components for consistency




State management and debounce implementation for business website
React State Management Implementation
	•	Use debouncing technique for form field updates
	◦	Implement in handler function, not useEffect
	◦	Update store first, then update local component state
	◦	Pattern: onChange → debounced store update → state update
	•	Centralized state approach required
	◦	All form questions must be added to store with default values on page load
	◦	Each page loads 5 questions → add all to currentForm with defaults
	◦	Store maintains all form data across components
Form Validation Architecture
	•	Validation runs when user clicks “Next” button
	◦	checkValidity method extracts data from form state
	◦	Generates config for each question (ID, value, ruleset)
	◦	Passes config to main validation service
	•	Centralized validation benefits
	◦	Consolidated error handling across components
	◦	Easier maintenance of validation rules
	◦	Better tracking and management
	•	Config structure includes
	◦	Question ID and form state values
	◦	Ruleset (max length, conditions, etc.)
	◦	Screen-specific validation configurations
Implementation Requirements
	•	Create similar validation function in Tax/residency folder
	◦	Follow business details validation pattern
	◦	Separate file for validation logic
	◦	Maintain centralized config approach
	•	Remove main hook dependencies
	◦	Priority task over other work
	◦	PKYC work is secondary priority
Action Items
	•	Complete state management refactor by EOD today
	◦	Implement debouncing pattern in handlers
	◦	Set up centralized validation system
	◦	Create Tax/residency validation function
	•	EOD deadline is firm and dynamic based on completion needs

Form validation implementation for tax residency
Form Validation Implementation Overview
	•	Moving from master hook approach to decentralized component-level state management
	•	Three-part implementation process for tax residency form validation
	•	Centralizing validations across application for common field types
	•	Divyansh created form validation service with designated design pattern
Technical Architecture Changes
	•	Removing existing master hook that manages all states
	•	Individual components will manage their own field states
	•	Form slice in Redux will maintain current form data
	◦	Contains all questions and answers for active form
	◦	Questions added dynamically when they appear on screen
	◦	No preemptive/proactive question addition
	•	Business validations stored separately from form state
	◦	Validation rules mapped when validation called
	◦	Tightly typed parameters required
Current Implementation Status
	•	Tax residency master hook removal in progress
	•	State management transition to individual components underway
	•	Validation service structure needs proper typing
	◦	Field objects require specific type definitions
	◦	Three common values across all fields
	◦	Condition parameter should be optional
Next Steps
	•	Call Divyansh after this meeting for detailed implementation guidance
	•	Update validation service with proper TypeScript typing
	•	Create type definitions for field objects and validation rules
	•	Implement form slice structure for current form state management
